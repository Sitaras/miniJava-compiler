Δημήτριος Σιταράς  |
1115201800178      |
————————————————————

► Οργάνωση Κώδικα:

.
├── README.txt
└── program
    ├── FirstVisitor.java
    ├── GeneratorVisitor.java
    ├── Main.java
    ├── Makefile
    ├── SymbolTable.java
    └── minijava.jj

---------------------------------------------------------------------------------------------
► Γενικά:

    → Ο κώδικας είναι σχολιασμένος.

    → Πληρούνται όλες οι προϋποθέσεις/απαιτήσεις που αναγράφονται στην εκφώνηση της άσκησης.

    → Το πρόγραμμα μεταγλωττίζεται και εκτελείται ως εξής:

        ► Eντολή μεταγλώττισης (υπάρχει Makefile): make
        ► Eντολή εκτέλεσης (όπως αναφέρεται στην εκφώνηση): java Main [file1] [file2] ... [fileN]

    → Τα αρχεία με κατάληξη .jar που ειναι απαραίτητα για την μεταγλώττιση του προγράμματος πρέπει να βρίσκονται στον ίδιο φάκελο με το README.txt
      (στο MakeFile έχω τα εξής: ../javacc5.jar, ../jtb132di.jar). Δηλαδή, η τελική οργάνωση του κώδικα για την μεταγλώττιση 
      του προγράμματος είναι η παρακάτω: 

        .
        ├── javacc5.jar
        ├── jtb132di.jar
        ├── README.txt
        └── program
            ├── FirstVisitor.java
            ├── GeneratorVisitor.java
            ├── Main.java
            ├── Makefile
            ├── SymbolTable.java
            └── minijava.jj

---------------------------------------------------------------------------------------------
► Διευκρινήσεις και παρατηρήσεις :

    → Απο την προηγούμενη εργασία μου (Semantic Check (MiniJava)) χρησιμοποιώ τα FirstVisitor.java και το SymbolTable.java.
      Δεν χρησιμοποιώ και επομένως δεν συμπεριέλαβα το SecondVisitor.java, διότι δεν μου χρειάζεται η σημασιολογική ανάλυση που προσφέρει ( με την υπόθεση βέβαια 
      πως τα αρχεία που δίνονται ειναι σημασιολογικά σωστά ).

        ► FirstVisitor.java : ειναι όπως την προηγούμενη μου εργασία, χωρίς καμια αλλαγή.

        ► SymbolTable.java : έχω προσθέσει 3 LinkedHashMap (2 στην κλάση ClassTable: allClassVars και methodsVtable και 1 στην κλάση MethodTable argsNameType)
          επίσης πρόσθεσα 4 μεθόδους (copyMethods, copyVars, getAllMethodsForTheVtable, getAllVariables), ώστε να καταφέρω να τυπώσω το V-table της κάθε κλασης
          καθώς και να κάνω διάφορους ελέγχους ( για το αν ειναι μεταβλήτη κλάσης ή τοπική μεταβλήτη ).
    
    → Για την παραγωγή του LLVM κώδικα βασίστηκα στα παραδείγματα του φροντιστηρίου και της εκφώνησης της άσκησης.
    
    → H πληροφορίες για τα offsets του κάθε πεδίου και της κάθε μεθόδου για την κάθε κλάση υπολογίζονται στην Main.java, όπου τυπώνονται και αποθηκεύονται στο Symbol Table,
      ακριβώς όπως στην προηγούμενη έργασία.
    
    → Για να ξέρω σε ποια εμβέλεια βρίσκομαι (δηλαδή σε ποια κλάση και σε ποια μέθοδο) χρησιμοποιώ 2 μεταβλητές τύπου String τις
      curClass και curMethod.
    
    → Σημεία που χρειάζονται επεξέγηση για το GeneratorVisitor.java :

        ► Χρησιμοποιώ την μεταβλήτη varTmp για να αποθηκεύω κάθε φορά την LLVM μεταβλήτη που περιέχει το αποτέλεσμα της έκφρασης ( που υπολογίζεται σε έναν visitor ), 
          ώστε να την "μεταφέρω" απο visitor σε visitor και να την χρησιμοποιώ όπου χρειάζεται. Έτσι καταφέρνω να επικοινωνούν οι visitors μεταξύ τους.
    
        ► Στον MessageSend visitor χρησιμοποιώ 2 στοίβες την varsStack ( περιέχει LLVM μεταβλητές για που προκύπτουν από "απλές" κλήσεις μέσω αντικειμένων κλάσης ) και την varsTmpStack ( περιέχει LLVM μεταβλητές που προκύπτουν από κλήσεις μέσω δέσμευσης αντικειμένου κλάσης ) 
          ώστε να "κρατάω" τις LLVM μεταβλητές σε περίπτωση συνεχόμενων κλήσεων μεθόδων μέσα σε μια έκφραση.

        ► Στις μεταβλητές intReturn και booleanReturn αποθηκεύω κάθε φορα τα integer literals και τα boolean literals που επιστρέφουν οι αντίστοιχοι visitors.
        
        ► Επίσης, έχω μια ουρά (queueBool) στην οποία αποθηκεύω τα boolean literals που "εμφανίζονται" ως ορίσματα στην κλήση μιας μεθόδου. Ουσιαστικά, την χρησιμοποιώ στον
          MessageSend visitor για να σχηματίσω το argument list σε περίπτωση που περιέχει boolean literals.

        ► Για να βρω το μέγεθος μια κλάσης ( field size ) όταν θέλω να κάνω allocation ενα αντικέιμενο αυτής (στον AllocationExpression visitor) ακολουθώ την εξής διαδικασία:
            1. Προσθέτω 8 λόγου του this.
            2. Πάω στo τελευταίο πεδίο της κλάσης (αν βεβαια υπάρχει έστω και ένα).
            3. Προσθέτω το αντίστοιχο offset αυτού του πεδίου.
            4. Τέλος, προσθέτω και το μέγεθος του πεδιού αυτού.
        
        ► Όταν χρησιμοποιείται οπουδήποτε το πεδίο μιας κλάσης τότε μέσω της μεθόδου toGetClassVar(...) ακολουθώ την παρακάτω διαδικασία:
            1. Βρίσκω σε ποια κλάση ορίζεται το συγκεκριμένο πεδίο.
            2. Βρίσκω το αντιστοιχο offset του.
            3. Παίρνω ενα δείκτη (σε LLVM επίπεδο) στο αντίστοιχο πεδίο της κλάσης με βάση το offset και κανω το απαραίτητο bitcast (επίσης σε LLVM επίπεδο).
        
        ► Παρόμοια διαδικασία ακολουθώ και για την κλήση μεθόδου μια κλάσης.
    